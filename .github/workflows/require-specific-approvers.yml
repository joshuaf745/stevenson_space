name: Require specific approvers

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted, dismissed]

permissions:
  pull-requests: read

jobs:
  check-approvals:
    name: check-approvals
    runs-on: ubuntu-latest
    env:
      # Set this repository variable in GitHub: Settings > Secrets and variables > Actions > Variables
      # Name: REQUIRED_APPROVERS, Value (comma-separated usernames): e.g. 'alice,bob,charlie'
      REQUIRED_APPROVERS: ${{ vars.REQUIRED_APPROVERS }}
      # Optional: override the number of approvals required. If unset, a simple majority of REQUIRED_APPROVERS is used.
      # Name: APPROVALS_REQUIRED, Value: e.g. '2'
      # Not currently used.
      APPROVALS_REQUIRED: ${{ vars.APPROVALS_REQUIRED }}
    steps:
      - name: Validate approvals from required users
        uses: actions/github-script@v7
        with:
          script: |
            const required = (process.env.REQUIRED_APPROVERS || '')
              .split(',')
              .map(s => s.trim().toLowerCase())
              .filter(Boolean);

            if (required.length === 0) {
              core.setFailed('REQUIRED_APPROVERS is not configured. Set it to a comma-separated list of usernames.');
              return;
            }

            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull_request payload; skipping.');
              return;
            }

            if (pr.draft) {
              core.info('Draft PR detected; skipping approval enforcement.');
              return;
            }

            const { owner, repo } = context.repo;
            const pull_number = pr.number;
            const headSha = pr.head && pr.head.sha ? pr.head.sha : undefined;

            if (!headSha) {
              core.setFailed('Unable to determine PR head SHA.');
              return;
            }

            // Fetch all reviews (paginate if necessary)
            let allReviews = [];
            let page = 1;
            while (true) {
              const { data } = await github.rest.pulls.listReviews({ owner, repo, pull_number, per_page: 100, page });
              allReviews = allReviews.concat(data || []);
              if (!data || data.length < 100) break;
              page += 1;
              if (page > 10) break; // safety cap
            }

            // Keep the latest review per user
            const latestByUser = new Map();
            for (const r of allReviews) {
              const username = (r.user && r.user.login ? r.user.login : '').toLowerCase();
              if (!username) continue;
              const prev = latestByUser.get(username);
              const currentTime = r.submitted_at ? new Date(r.submitted_at).getTime() : 0;
              const prevTime = prev && prev.submitted_at ? new Date(prev.submitted_at).getTime() : 0;
              if (!prev || currentTime >= prevTime) {
                latestByUser.set(username, r);
              }
            }

            // Evaluate approvals from the designated approvers on the current head SHA
            const approvedBy = [];
            for (const username of required) {
              const review = latestByUser.get(username);
              if (review && review.state === 'APPROVED' && review.commit_id === headSha) {
                approvedBy.push(username);
              }
            }

            const configured = Number.parseInt(process.env.APPROVALS_REQUIRED || '', 10);
            const majority = Math.floor(required.length / 2) + 1;
            const requiredCount = Number.isFinite(configured) && configured > 0
              ? Math.min(configured, required.length)
              : majority;

            core.info(`Designated approvers: ${required.join(', ')}`);
            core.info(`Approved by (latest head): ${approvedBy.join(', ') || 'none'}`);
            core.info(`Approvals required: ${requiredCount} (policy: ${Number.isFinite(configured) && configured > 0 ? 'fixed' : 'majority'})`);

            if (approvedBy.length < requiredCount) {
              const remaining = requiredCount - approvedBy.length;
              const stillEligible = required.filter(u => !approvedBy.includes(u));
              core.setFailed(`Insufficient approvals: ${approvedBy.length}/${requiredCount}. Need ${remaining} more from: ${stillEligible.join(', ')}`);
              return;
            }

            core.info('All required approvers have approved the latest commit.');

