name: Require dedicated contributor approval

on:
  # Use pull_request_target so secrets are available for forks; do NOT checkout PR code in this job
  pull_request_target:
    types: [opened, reopened, synchronize, ready_for_review]
  # Keep review events for same-repo PRs; for forks, the target run above enforces the rule
  pull_request_review:
    types: [submitted, dismissed]

permissions:
  pull-requests: write
  contents: read

jobs:
  check-approvals:
    name: check-approvals
    runs-on: ubuntu-latest
    steps:
      - name: Validate approvals from required users
        uses: actions/github-script@v7
        with:
          # Use the PAT for all API calls
          github-token: ${{ secrets.TEAM_MEMBERS_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull_request payload; skipping.');
              return;
            }

            if (pr.draft) {
              core.info('Draft PR detected; skipping approval enforcement.');
              return;
            }

            const prAuthor = pr.user && pr.user.login ? pr.user.login.toLowerCase() : undefined;
            core.info(`PR #${pr.number} by ${prAuthor}`);

            // Hardcoded team configuration
            const teamOrg = 'stevenson-space';
            const teamSlug = 'dedicated-contributors';
            
            // Fetch team members using the PAT
            let teamMembers = [];
            try {
              let page = 1;
              while (true) {
                const { data } = await github.rest.teams.listMembersInOrg({
                  org: teamOrg,
                  team_slug: teamSlug,
                  per_page: 100,
                  page: page
                });
                teamMembers = teamMembers.concat((data || []).map(u => (u.login || '').toLowerCase()).filter(Boolean));
                if (!data || data.length < 100) break;
                page += 1;
                if (page > 20) break; // safety cap
              }
            } catch (e) {
              core.setFailed(`Unable to list team members for ${teamOrg}/${teamSlug}: ${e.message}`);
              return;
            }

            if (teamMembers.length === 0) {
              core.setFailed(`No members found in team ${teamOrg}/${teamSlug}`);
              return;
            }

            core.info(`Team members found: ${teamMembers.join(', ')}`);

            // Exclude the PR author from eligible approvers
            const eligible = teamMembers.filter(u => u !== prAuthor);
            
            if (eligible.length === 0) {
              core.setFailed('No eligible approvers in the team after excluding the PR author.');
              return;
            }

            // Calculate half or more (50% rounded up)
            const requiredCount = Math.ceil(eligible.length / 2);
            core.info(`Eligible approvers (excluding PR author): ${eligible.join(', ')}`);
            core.info(`Required approvals: ${requiredCount} out of ${eligible.length} (half or more)`);

            const { owner, repo } = context.repo;
            const pull_number = pr.number;
            const headSha = pr.head && pr.head.sha ? pr.head.sha : undefined;

            if (!headSha) {
              core.setFailed('Unable to determine PR head SHA.');
              return;
            }

            core.info(`Current head SHA: ${headSha}`);

            // Fetch all reviews (paginate if necessary)
            let allReviews = [];
            let page = 1;
            while (true) {
              const { data } = await github.rest.pulls.listReviews({ 
                owner, 
                repo, 
                pull_number, 
                per_page: 100, 
                page 
              });
              allReviews = allReviews.concat(data || []);
              if (!data || data.length < 100) break;
              page += 1;
              if (page > 10) break; // safety cap
            }

            core.info(`Total reviews found: ${allReviews.length}`);

            // Keep the latest review per user
            const latestByUser = new Map();
            for (const r of allReviews) {
              const username = (r.user && r.user.login ? r.user.login : '').toLowerCase();
              if (!username) continue;
              const prev = latestByUser.get(username);
              const currentTime = r.submitted_at ? new Date(r.submitted_at).getTime() : 0;
              const prevTime = prev && prev.submitted_at ? new Date(prev.submitted_at).getTime() : 0;
              if (!prev || currentTime >= prevTime) {
                latestByUser.set(username, r);
              }
            }

            // Count approvals from eligible team members on the current head SHA
            const approvedBy = [];
            const dismissedOrChangesBy = [];
            
            for (const username of eligible) {
              const review = latestByUser.get(username);
              if (!review) {
                continue;
              }
              
              core.info(`${username}: state=${review.state}, commit=${review.commit_id}, current=${headSha}`);
              
              if (review.commit_id === headSha && review.state === 'APPROVED') {
                approvedBy.push(username);
              } else if (review.state === 'CHANGES_REQUESTED' || review.state === 'DISMISSED') {
                dismissedOrChangesBy.push(username);
              }
            }

            core.info(`Approved by (on current commit): ${approvedBy.join(', ') || 'none'}`);
            core.info(`Changes requested or dismissed: ${dismissedOrChangesBy.join(', ') || 'none'}`);

            if (approvedBy.length < requiredCount) {
              const remaining = requiredCount - approvedBy.length;
              const stillNeeded = eligible.filter(u => !approvedBy.includes(u));
              core.setFailed(
                `❌ Insufficient approvals: ${approvedBy.length}/${requiredCount}.\n` +
                `Need ${remaining} more approval(s) from eligible reviewers.\n` +
                `Still can approve: ${stillNeeded.join(', ')}`
              );
              return;
            }

            core.info(`✅ Success! ${approvedBy.length}/${requiredCount} required approvals received.`);
